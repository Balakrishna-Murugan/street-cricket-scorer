import React, { useState, useEffect, useCallback } from 'react';
import {
  Box,
  Paper,
  Typography,
  Grid,
  Button,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  SelectChangeEvent,
} from '@mui/material';
import { useParams } from 'react-router-dom';
import { Match, Player } from '../types';
import { matchService, playerService } from '../services/api.service';

const LiveScoring: React.FC = () => {
  const { matchId } = useParams();
  const [match, setMatch] = useState<Match | null>(null);
  const [loading, setLoading] = useState(true);
  const [players, setPlayers] = useState<Player[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [currentInnings, setCurrentInnings] = useState(0);
  const [striker, setStriker] = useState<string | null>(null);
  const [nonStriker, setNonStriker] = useState<string | null>(null);
  const [bowler, setBowler] = useState<string | null>(null);
  const [currentInningData, setCurrentInningData] = useState<Match['innings'][0] | null>(null);
  const [battingTeam, setBattingTeam] = useState<string | null>(null);

  const fetchPlayers = useCallback(async () => {
    try {
      const response = await playerService.getAll();
      setPlayers(response.data);
    } catch (error) {
      setError('Error fetching players');
      console.error('Error:', error);
    }
  }, []);

  const fetchMatch = useCallback(async () => {
    try {
      if (!matchId) return;
      const response = await matchService.getById(matchId);
      const matchData = response.data;
      setMatch(matchData);
      
      // Initialize striker, non-striker, and bowler if not set
      if (matchData && matchData.innings && matchData.innings.length > 0) {
        const currentInning = matchData.innings[currentInnings];
        if (!striker && currentInning.battingStats.length > 0) {
          setStriker(currentInning.battingStats[0].playerId);
        }
        if (!nonStriker && currentInning.battingStats.length > 1) {
          setNonStriker(currentInning.battingStats[1].playerId);
        }
        if (!bowler && currentInning.bowlingStats.length > 0) {
          setBowler(currentInning.bowlingStats[0].playerId);
        }
      }
    } catch (error) {
      setError('Error fetching match details');
      console.error('Error:', error);
    } finally {
      setLoading(false);
    }
  }, [matchId, currentInnings, striker, nonStriker, bowler]);

  const handleBatsmanChange = (event: SelectChangeEvent) => {
    setStriker(event.target.value);
  };

  const handleNonStrikerChange = (event: SelectChangeEvent) => {
    setNonStriker(event.target.value);
  };

  const handleBowlerChange = (event: SelectChangeEvent) => {
    setBowler(event.target.value);
  };

  const switchStrike = () => {
    const temp = striker;
    setStriker(nonStriker);
    setNonStriker(temp);
  };

  // Initial data fetch
  useEffect(() => {
    fetchMatch();
    fetchPlayers();
  }, [fetchMatch, fetchPlayers]);

  // Update current inning data when match or innings changes
  useEffect(() => {
    if (match && match.innings?.[currentInnings]) {
      setCurrentInningData(match.innings[currentInnings]);
      setBattingTeam(match.innings[currentInnings].battingTeam);
    }
  }, [match, currentInnings]);

  const availableBatters = players.filter((player) => 
    player.teams?.includes(battingTeam || '') && 
    !currentInningData?.battingStats.find(
      (stat) => stat.playerId === player._id && stat.isOut
    )
  );

  if (loading) {
    return <Typography>Loading...</Typography>;
  }

  if (error) {
    return <Typography color="error">{error}</Typography>;
  }

  if (!match) {
    return <Typography>Match not found</Typography>;
  }

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h4" gutterBottom>
        Live Scoring
      </Typography>

      {/* Score Summary */}
      <Paper sx={{ p: 2, mb: 3 }}>
        <Typography variant="h5">
          {currentInningData?.totalRuns || 0}/{currentInningData?.wickets || 0}
        </Typography>
        <Typography variant="subtitle1">
          Overs: {currentInningData?.overs || 0}
        </Typography>
        <Typography variant="subtitle2">
          {players.find((p) => p._id === striker)?.name || 'Select Striker'} *
        </Typography>
        <Typography variant="subtitle2">
          {players.find((p) => p._id === nonStriker)?.name || 'Select Non-striker'}
        </Typography>
        <Typography variant="subtitle2">
          Bowler: {players.find((p) => p._id === bowler)?.name || 'Select Bowler'}
        </Typography>
      </Paper>

      {/* Player Selection */}
      <Grid container spacing={3} sx={{ mb: 3 }}>
        <Grid item xs={12} md={4}>
          <FormControl fullWidth>
            <InputLabel id="striker-label">Striker</InputLabel>
            <Select
              labelId="striker-label"
              value={striker || ''}
              label="Striker"
              onChange={handleBatsmanChange}
            >
              {availableBatters.map((player) => (
                <MenuItem key={player._id} value={player._id}>
                  {player.name}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </Grid>

        <Grid item xs={12} md={4}>
          <FormControl fullWidth>
            <InputLabel id="non-striker-label">Non-Striker</InputLabel>
            <Select
              labelId="non-striker-label"
              value={nonStriker || ''}
              label="Non-Striker"
              onChange={handleNonStrikerChange}
            >
              {availableBatters
                .filter((player) => player._id !== striker)
                .map((player) => (
                  <MenuItem key={player._id} value={player._id}>
                    {player.name}
                  </MenuItem>
                ))}
            </Select>
          </FormControl>
        </Grid>

        <Grid item xs={12} md={4}>
          <FormControl fullWidth>
            <InputLabel id="bowler-label">Bowler</InputLabel>
            <Select
              labelId="bowler-label"
              value={bowler || ''}
              label="Bowler"
              onChange={handleBowlerChange}
            >
              {players
                .filter((player) => 
                  player.role === 'bowler' || player.role === 'all-rounder'
                )
                .map((player) => (
                  <MenuItem key={player._id} value={player._id}>
                    {player.name}
                  </MenuItem>
                ))}
            </Select>
          </FormControl>
        </Grid>
      </Grid>

      <Box sx={{ mb: 2 }}>
        <Button variant="contained" onClick={switchStrike}>
          Switch Strike
        </Button>
      </Box>
    </Box>
  );
};

export default LiveScoring;